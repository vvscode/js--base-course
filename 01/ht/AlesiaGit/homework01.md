# Что такое замыкание?
__Замыкания__ – функция со всем переменными, которые ей доступны. Функция создается в лексическом окружении и ей присваивается свойство [[Scope]], которое его означает. При вызове функции она сначала ищет переменные в своем лексическом окружении, если их нету, то поднимается вверх. Самое лексическое окружение верхнего уровня – Window.
# Что такое this ? Чем определяется? Как его изменить?
__This__ – ключевое слово, которое используется для доступа к свойствам текущего объекта из метода. Метод – свойство-функция объекта. This определяется контекстом, в котором оно вызывается. Если одну и ту же функцию запускать в разных объектах (= в разных контекстах), то она будет получать разные this. 
> __Note__: this – это текущий объект при вызове «через точку» и новый объект при конструировании через new.
1.	Function (arguments) -> this=window;
2.	Object.function(arguments) -> this=object;
3.	Function.apply(object, arguments) -> this=object;
4.	new Function(arguments) -> this=new object;

```javascript
var f = {
	name: 'Jane', 
	gender: 'female', 
	militaryService: function() {
  	if (this.gender == 'male') { 
    	return true;
    }
   }
};

var m = {
	name: 'Peter', 
	gender: 'male', 
	militaryService: function() {
  	if (this.gender == 'male') { 
    	return true;
    } 
   }
};

console.log(m.militaryService());
```
# Как узнать сколько параметров принимает функция?
```javascript
console.log((function Sum(a, b, c, d, e){}).length);
```
# Что такое прототипное наследование? Как в js реализовать наследование одного "класса" от другого?
__Наследование__ – это создание новых «классов» на основе существующих. Чтобы наследник имел доступ к свойству, оно должно быть записано в this. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype. При создании объекта через new, в его прототип __ proto __ записывается ссылка из prototype функции-конструктора.
__Способ 1:__ Через __ proto__ (наследование объектов)
```javascript
var person = {
	born: true
};

function Baby(gender) {
	this.gender = gender;
  this.__proto__ = person;
}

var baby = new Baby('girl');

console.log(baby.born);
```

__Способ 2:__ Через конструктор (наследование классов)
```javascript
function Person(gender) { //конструктор родителя, которые описывает его свойства кроме методов
	this.gender = gender;
}

Person.prototype.born = function() { // методы складываются отдельно в прототип
	console.log("A " + this.gender + " is born!");
}

function Woman(gender) { // конструктор потомка, где this = контекст родителя
	Person.apply(this, arguments);
}

Woman.prototype = Object.create(Person.prototype); //наследование методов родителя

Woman.prototype.born = function () { // методы потомка
	Person.prototype.born.apply(this);
  console.log("She is beautiful!");
};

var baby = new Woman("girl"); //создание объекта
```
#	Как узнать есть ли у объекта свойство x ?
```javascript
var user = {
	name: "Bob",
  x: 18
}

console.log(user.hasOwnProperty('x'));
```
# Что происходит при использовании ключевого слова new?
При сипользовании ключевого слова __new__ выделяется новый кусок памяти и вызывается функция конструктора у которой this теперь указывает на этот новый выделенный кусок памяти. Поэтому каждый раз когда вызывается __new__ создаётся новый экземпляр объекта. Если вызвать функцию конструктора без __new__, то память не выделяется, следовательно __this__ подменять нечем, поэтому подменяется Window-ом.
# Как сделать ревес строки? Как удалить предпоследний элемент в массиве?
```javascript
// реверс строки
var string = 'лето';
var arr = string.split('');
var reverseArr = arr.reverse();
var reverseString = reverseArr.join('');
console.log(reverseString);

// убрать значение
delete arr[arr.length - 2];
console.log(arr);

// убрать элемент полностью
arr.splice(-2,1);
console.log(arr); 
```
# Как заменить в строке "papa roach" все буквы a на A ?
```javascript
var string = 'papa roach';
var arr = string.split('');
console.log(arr);
for (var i = 0; i < arr.length; i++) {
	if (arr[i] == "a") {
  	arr[i] = arr[i].toUpperCase();
  }
}
console.log(arr);
```
# Как найти на странице div с id someId ?
```javascript
var smth = document.getElementById('someId');

var x = document.body.children;
for (var i = 0; i < x.length; i++) {
    if (x[i].matches('#someId')) {
      console.log("found");
    }
}
```
# Как устроен событийный цикл в js?
Каждое событие должно быть полностью обработано, прежде чем начнет обрабатываться следующее. В браузерах события добавляются в очередь в любое время, если событие произошло (if true), а также если у него есть обработчик (onclick). Нулевая задержка (e.g. setTimeout) не дает гарантии, что обработчик выполнится через ноль миллисекунд. Выполнение зависит от количества ожидающих задач в очереди. Поток выполнения никогда не блокируется (alert – исключение).
# Как можно проитерироваться по всем полям объекта? 
__Если объект - массив:__
```javascript
// способ 1 (цикл)
var arr = ["a", "b", "c"]; 
for (var i = 0; i < arr.length; i++) { 
	console.log(arr[i]); 
}

// способ 2 (forEach)
var arr = ["a", "b", "c"];
arr.forEach(function(entry) {
    console.log(entry);
});
```
__Если объект НЕ массив:__
```javascript
var a = {o: "a", test: 12, br1: "c"};
for (var key in a) {
    console.log(key + ": " + a[key]);
}
```
# Что такое callback ? 
__Callback__ - это функция, которая обычно передаётся в другую функцию как параметр и вызывается после выполнения каких-то действий.
```javascript
function process(a, b, callback) {
	var c = a + b;
  callback(c); // поручаем callback-функции показать результат
}

// вызов одной и той же функции с разными callback-ами
process(1,2, function(result) {
	alert("result: " + result); // в окно
});

process(1,2, function(result) {
	console.log("result: " + result); // на консоль
});
```
# Какие методы массива являются функциями высшего порядка ?
__Функция высшего порядка__ - это функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. 
# Как добавить новый метод всем не falsy данным в программе?
```javascript
var o = {name: 'Olga', age: 13};
var m = {name: 'Michael', age: 20};
var school = {o, m};

for (var key in school) {
	if (school[key].age > 18) {
  	school[key].func = function() {console.log("Hello " + this.name)};
	}
}

console.log(school);
```
# Как и когда работает преобразование типов?
__Строковое преобразование__ происходит, когда требуется представление чего-либо в виде строки. 
String(value) или +value

__Численное преобразование__ происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений = = =, !==).
Undefined = NaN
Null = 0
True/false = 1/0
String = 0 (empty string) / не-0 (read number or NaN)

__Логическое преобразование__ происходит в логическом контексте, таком как if(value), и при применении логических операторов.
Undefined, null = false
Number = true (0 = false)
String = true (“” = false)
Object = true

1 + ‘2’ = 12 // из-за + все выражение привелось к строке
1 – ‘2’ = -1 // строка согласно правилам численного преобразования привелась к 2. дальше арифметика

# Что такое API? Примеры?
__Application Programming Interface__ — это интерфейс программирования, интерфейс создания приложений. API облегчает задачу написания приложения благодаря использованию готового кода (например, функций). Например, JQuery.
# Как в js реализовать многопоточность?
__JS - однопоточный язык программирования.__ однако, в нём есть поддержка отложенного выполнения, когда мы устанавливаем обработчик события timeout и выходим из программы. При этом можно повесить несколько обработчиков, образующих конкурентную очередь выполнения. Эта их особенность и позволяет реализовать многопоточность в JS.
# Что такое HTTP ? Из чего состоит HTTP протокол?
HTTP — протокол передачи данных. Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
1.	Стартовая строка (англ. Starting line) — определяет тип сообщения;
2.	Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
3.	Тело сообщения (англ. Message Body) — непосредственно данные сообщения.
# Какие есть методы HTTP запросов? Для чего каждый?
__Методы HTTP__ - последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом.
1. OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.
2. GET - Используется для запроса содержимого указанного ресурса. 
3. HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. 
4. PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI.
5. PATCH - Аналогично PUT, но применяется только к фрагменту ресурса.
6. DELETE - Удаляет указанный ресурс.
7. TRACE - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.
8. CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.
# Что такое пакетный менеджер? Какие пакетные менеджеры есть для js?
__Пакетный менеджер__ - набор программного обеспечения, позволяющего управлять процессом установки, удаления, настройки и обновления различных компонентов программного обеспечения. npm (Node.js Package Manager) — менеджер пакетов, входящий в состав Node.js.
# Что делают системы сборки? Какие системы сборки есть для js?
Grunt, Gulp. Они конкатенируют JS-файлы в один в нужном порядке, проверяют JS-код на валидность, минимизируют код, по необходимости его обфусцирует (делают непонятным), конкатенируют и минимизируют CSS-файлы, складывает файлики в отдельную директорию, из которой они подключаются в HTML.
# Что такое "всплытие событий"?
При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.
# Что такое "делегирование" событий?
Если есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – устанавливается один обработчик общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.




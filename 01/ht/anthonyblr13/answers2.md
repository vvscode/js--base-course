#Что такое замыкание?
Замыкание — это функция, объявленная внутри другой функции и имеющая доступ к переменным внешней (вмещающей) функции. Замыкание имеет доступ сразу к трем областям видимости:

к своей собственной области видимости (переменные, объявленные внутри замыкания);
к области видимости внешней функции (переменные, объявленные внутри внешней функции);
к глобальной области видимости.
#Что такое this? Чем определяется? Как его изменить?
`this` зависит от контекста вызова, например

    function f() {
        console.log(this === window); // true
    }
    f();

в данном случае this внутри функции f равен глобальному объекту( в браузере window)
При создании функции-конструктора


    function f() {
        this.x = 5;
        console.log(this === window); // false
    }
    var o = new f();
    console.log(o.x === 5); // true

в данном случае `this` указывает на вновь создаваемый объект
можно изменить при помощи call, apply, bind
#Как узнать сколько параметров принимает функция?

    function person(name, age){
                console.log(name, age)
            }
            person("Homer", 35);
            console.log(person.length);
#Что такое прототипное наследование?
Это означает, что в JavaScript объекты наследуются от других объектов. Простые объекты в JavaScript, созданные с использованием `{}` фигурных скобок, имеют только один прототип: `Object.prototype. Object.prototype`, в свою очередь тоже объект, и все свойства и методы `Object.prototype` доступны для всех объектов.

Массивы, созданные с помощью `[]` квадратных скобок, имеют несколько прототипов, в том числе `Object.prototype` и `Array.prototype`. Это означает, что все свойства и методы `Object.prototype` и `Array.prototype` доступны для всех массивов. Одноименные свойства и методы, например `.valueOf` и `.toString`, вызываются из ближайшего прототипа, в этом случае из `Array.prototype`.

#Как узнать есть ли у объекта свойство `x`?
 

    var myObject = {
	    name: "Jack",
	    gender: "male"
	}  
	console.log(myObject.hasOwnProperty("name")); // true
    console.log("gender" in myObject); // true  

Отличие в том, что `hasOwnProperty` выведет `true` только если свойство есть непосредственно у данного объекта, т.е не наследованно от прототипа, а `in` выведет `true` в обоих случаях. 
#Что происходит при использовании ключевого слова `new`?

    var Person, person, anotherPerson;
    
    Person = function(name){
      this.name = name;    // функция-конструктор 
    };
    
    person = new Person("Jack"); // при вызове с new получаем новый объект
    console.log(person.name);  // Jack
    
    anotherPerson = new Person("Bruce");
    console.log(person.name); // Bruce
    console.log(Person.prototype) // Object{}
Функция-конструктор имеет свойство  `prototype,` в котором хранится прототип свойства которое будут наследовать все объекты создаваемые при помощи конструктора. Изначально это пустой объект, но мы можем задавать его свойства и методы, которые будут доступны всем объектам созданным при помощи данного конструктора.

    Person = function(name){
      this.name = name;    // функция-конструктор 
    };
    
    Person.prototype.greet = function() {
      console.log("Hello " + this.name)
    };
    
    person = new Person("Jack"); // при вызове с new получаем новый объект
    console.log(person.name);  // Jack
    person.greet(); // Hello Jack
    
    anotherPerson = new Person("Bruce");
    console.log(person.name); // Bruce
    anotherPerson.greet(); // Hello Bruce
Проверка является ли объект прототипом конструктора можно осуществить с помощью бинарного оператора `instanceof`   либо с помощью метода `isPrototypeOf` 

    console.log(person instanceof Person) // true
    console.log(Person.prototype.isPrototypeOf(person)); // true
#Как сделать реверс строки?

    strReverse = str.split('').reverse().join(''); //Разбиваем строку посимвольно  и превращаем ее в массив с помощью split(''), потом применяем к нему метод reverse() и собираем все символы в строку с помощью join('')	
#Как удалить предпоследний элемент в массиве?

    arr = [1, 2, 3, 4, 5, 6];
    var deleteCount = arr.splice(arr.length-2, 1);
    console.log(arr); // [1, 2, 3, 4, 6]	
#Сколькими способами ( с примерами кода ) можно найти на странице div с id someId ?

    <div id = "test">Test</div> 
    <script>
      var elem = document.getElementById('test');
      elem.style.background = 'green';
    </script> 
#Как устроен событийный цикл в js?
Модель событийного цикла (event loop) называется так, потому что отслеживает новые события в цикле:

    while(queue.waitForMessage()){
      queue.processNextMessage();
    }

`queue.waitForMessage` ожидает события если очередь пуста.

Каждое событие должно быть полностью обработано, прежде чем начнет обрабатываться следующее. Благодаря этому мы можем точно знать: когда бы и где бы не выполнялась функция – она не может быть приостановлена, и будет целиком завершена до начала выполнения другого кода (который может изменять данные, с которыми работает текущая функция). Это отличает JavaScript от такого языка программирования как C. Поскольку в С функция, запущенная в отдельном потоке, в любой момент может быть остановлена, чтобы выполнить какой-то другой код в другом потоке.

У данного подхода есть и минусы. Если событие обрабатывается слишком долго, то приложение в это время не имеет возможности обработать действия пользователя (например, скролл, или клик). Браузер может смягчать последствия такой проблемы. *Internet Explorer,* в таком случае, выводит сообщение *"A script on this page is causing Internet Explorer to run slowly"* и предлагает завершить обработку слишком тяжелого события. Хорошая практика для предохранения от этого – не создавать события, которые могут выполняться долго, и разбивать большие события на несколько мелких.

Добавление событий в очередь

В браузерах события добавляются в очередь в любое время, если событие произошло, а так же если у него есть обработчик. В случае, если обработчика нет – событие потеряно. Так, клик по элементу, имеющему обработчик события по событию click – добавит событие в очередь, а если обработчика нет – то и событие в очередь не попадет.

Вызов `setTimeout` добавит событие в очередь по прошествии времени, указанного во втором аргументе вызова. Если очередь событий на тот момент будет пуста, то событие обработается сразу же, в противном случае, событию функции `setTimeout` придется ожидать завершения обработки остальных событий в очереди. Именно поэтому второй аргумент `setTimeout` корректно считать не временем, через которое выполнится функция из первого аргумента, а минимальное время, через которое она сможет выполниться.		
#Что такое API? Примеры?
Аббревиатура расшифровывается как Application Programming Interface, или интерфейс для программирования приложений.
API – это, в первую очередь, интерфейс. Интерфейс, который позволяет разработчикам использовать готовые блоки для построения приложения.
В случае веб-приложений, API может отдавать данные в отличном от стандартного HTML формате, благодаря чему им удобно пользоваться при написании собственных приложений. Сторонние общедоступные API чаще всего отдают данные в одном из двух форматов: XML или JSON.
Github – имеет свой API, которым могут воспользоваться другие разработчики. То, как они будут пользоваться им зависит от возможностей, которые предоставляет API и от того, насколько хорошо работает фантазия у разработчиков. API Гитхаба позволяет, например, получать информацию о пользователе, его аватаре, читателях, репозиториях и множество других полезных и интересных сведений.

Если взять, к примеру, API Твиттера, то интерфейс этого сервиса может выдать вам информацию о твитах пользователя, его читателях и о тех, кто его читает, и так далее. Это лишь малая часть возможностей, которые любой желающий может воплотить, используя API стороннего сервиса или создавая свой собственный.
#Как в js реализовать наследование одного "класса" от другого? Пример кода
	var ObjectProto = {
      name: "Bill"
    };
    
    var object = Object.create(ObjectProto);
    console.log(object.name); // Bill


    var Person, person, anotherPerson;
        
        Person = function(name){
          this.name = name;    // функция-конструктор 
        };
        
        person = new Person("Jack"); // при вызове с new получаем новый объект
        console.log(person.name);  // Jack
        
        anotherPerson = new Person("Bruce");
        console.log(person.name); // Bruce
        console.log(Person.prototype) // Object{}
#Сколькими способами можно проитерироваться по всем полям объекта? С примерами кода
Для перебора всех свойств объекта используется специальный вид конструкции `for, for..in:`

    for(var key in object) {
      // key - название свойства
      // object[key] - значение свойства
      ...
    }

    for(prop in object) {
        if (!object.hasOwnProperty(prop)) continue
        //...
    };
Эта форма отфильтровывает свойства, которые принадлежат не самому объекту, а его прототипу. Поэтому она работает, даже если в прототип `Object` добавлены новые свойства.
#Что такое callback ? Зачем ? Пример кода
Функция обратного вызова — это функция, которая передается другой функции в качестве параметра и та, в свою очередь, вызывает переданную функцию.
Все функции в JavaScript являются объектами, и именно поэтому мы можем подобно объектам создавать их, передавать в качестве параметров другим функциям, возвращать в качестве результата функции.
Когда мы передаем одну функцию другой в качестве параметра — мы фактически передаем ее определение. На этом этапе передаваемая функция не вызывается и не выполняется.
А так как вторая функция имеет определение функции обратного вызова в качестве одного из параметров, она может выполнить обратный вызов в любое время. Это позволяет нам выполнять функции обратного вызова в любой точке содержащих их функций.
Функция обратного вызова не выполняется немедленно. Точка внутри содержащей функции, в которой вызывается функция обратного вызова как раз и называется «обратным вызовом».

    function foo(callback) { return callback(); }
     
    foo (function() { alert("Hello!"); });
#Как добавить новый метод всем не falsy данным в программе?

#Почему 1 + '2' ? и 1 - '2' ?
В первом случае js произведет конкатенацию строк и мы получим результат "12" (т.к. если при бинарном операторе + один из операндов строка, то второй операнд будет приведен к строке). Во втором случае получим -1, т.к. js приведет строку к числу и результатом будет разница двух чисел.
#Как и когда работает преобразование типов?    
Всего есть три преобразования:
1.Строковое преобразование.
2.Числовое преобразование.
3.Преобразование к логическому значению.
Строковое

    console.log(String(undefined)); // "undefined"
    console.log("323" + undefined); // "323undefined"
    
Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений `===, !==`).
Для преобразования к числу в явном виде можно вызвать `Number(val),` либо, что короче, поставить перед выражением унарный плюс `"+"`:

    console.log(+"123"); // 123
    console.log(Number("123")); // 123

Логическое преобразование:
Преобразование к `true/false` происходит в логическом контексте, таком как `if(value)`, и при применении логических операторов.

Все значения, которые интуитивно «пусты», становятся `false`. Их несколько: `0, пустая строка, null, undefined и NaN`.

Остальное, в том числе и любые объекты – `true`.
#Что такое HTTP ? Из чего состоит HTTP протокол?
HTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам).
Аббревиатура HTTP расшифровывается как HyperText Transfer Protocol, «протокол передачи гипертекста». В соответствии со спецификацией  HTTP является протоколом прикладного  уровня. 
Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.
Задача, которая традиционно решается с помощью протокола HTTP — обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером. На данный момент именно благодаря протоколу HTTP обеспечивается работа Всемирной паутины.
Также HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. В таком случае говорят, что протокол HTTP используется как «транспорт».
API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут иметь любой формат, например, XML или JSON.
Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения. Серверное программное обеспечение при этом обычно использует TCP-порт 80 (и, если порт не указан явно, то обычно клиентское программное обеспечение по умолчанию использует именно 80-й порт для открываемых HTTP-соединений), хотя может использовать и любой другой.
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
Стартовая строка (англ. Starting line) — определяет тип сообщения;
Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
Тело сообщения (англ. Message Body) — непосредственно данные сообщения.
#Какие есть методы HTTP запросов? Для чего каждый?
**1.HTTP метод GET**

Метода GET в HTTP используется для получения информации от сервера по заданному URI (URI в HTTP). Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные.
	**2.HTTP метод HEAD**
HTTP метод HEAD работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения.
	**3.HTTP метод POST**
HTTP метод POST используется для отправки данных на сервер, например, из HTML форм, которые заполняет посетитель сайта.
	**4.HTTP метод PUT**
HTTP метод PUT используется для загрузки содержимого запроса на указанный в этом же запросе URI.
	**5.HTTP метод DELETE** 
HTTP метод DELETE удаляет указанный в URI ресурс.
	**6.HTTP метод CONNECT**
HTTP метод CONNECT преобразует существующее соединение в тоннель.
	**7.HTTP метод OPTIONS**
HTTP метод OPTIONS используется для получения параметров текущего HTTP соединения.
	**8.HTTP метод TRACE**
HTTP метод TRACE создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи.
#Что такое REST ? RPC ?
REST— архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC. 
RPC-класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). Обычно реализация RPC технологии включает в себя два компонента: сетевой протокол для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для необъектных RPC). Различные реализации RPC имеют очень отличающуюся друг от друга архитектуру и разнятся в своих возможностях: одни реализуют архитектуру SOA, другие CORBA или DCOM. На транспортном уровне RPC используют в основном протоколы TCP и UDP, однако, некоторые построены на основе HTTP (что нарушает архитектуру ISO/OSI, так как HTTP изначально не транспортный протокол).
#Что такое пакетный менеджер? Какие пакетные менеджеры есть для js? 
Менеджеры пакетов упрощают установку и обновление зависимостей проекта, то есть сторонних библиотек, которые он использует: jQuery, Fotorama, все, что используется на твоем сайте и написано не тобой.
Хождение по сайтам библиотек, скачивание и распаковка архивов, копирование файлов в проект — все это заменяется парой команд в терминале.
Пакетные менеджеры js (npm, Jam, Component, Volo, Ender, Bower)
#Что делают системы сборки? Какие системы сборки есть для js?
Объем и сложность CSS и JS увеличиваются, и вид, в котором удобно разрабатывать,  сильно отличается от вида, в котором нужно показывать результат пользователю. Появились такие задачи, как конкатенация (склеивание) файлов, минимизация кода и даже предварительная компиляция. Результатом этого стали специализированные системы сборки:
Grunt, Gulp, Gear, Brunch
#Как с помощью gulp минифицировать js файл?
Gulp построен на Node.js, и файл сборки пишется на JavaScript. Сам по себе Gulp умеет не очень много, но имеет огромное количество плагинов, которые можно найти на странице со списком плагинов или просто поиском на npm. Например, есть плагины для запуска JSHint, компиляции CoffeeScript, запуска тестов и даже для обновления номера версии сборки.

Установка Gulp крайне проста. Сначала установите его глобально:

    //Bash
    npm install -g gulp

А потом для приложения:

    //Bash
    npm install --save-dev gulp

Работа с Gulp
Cоздадим первый таск для минификации JavaScript файлов (предположим, у нас есть один файл app.js в директории js). Для этого необходимо создать файл gulpfile.js в корне проекта, именно отсюда мы будем запускать таск с помощью команды gulp. Поместим в файл gulpfile.js следующий код:

    //JavaScript
    var gulp = require('gulp'),
        uglify = require('gulp-uglify');
    
    gulp.task('minify', function () {
        gulp.src('js/app.js')
            .pipe(uglify())
            .pipe(gulp.dest('build'));
    });

Теперь установим плагин gulp-uglify:

    //Bash
    npm install --save-dev gulp-uglify

И запустим команду gulp minify. Можно убедиться, что в директории build создана минифицированная версия app.js.
#Что такое "всплытие событий"?
Рассмотрим следующую ситуацию

    <div onclick="alert('div');" style="width:100px;height:100px; background:cornflowerblue">
        <button onclick="alert('button')">
            Не нажимать!
        </button>
    </div>

Если мы кликаем на кнопку, то формально мы кликаем и на `div`. Где же определить событие `onclick`?
В JavaScript эта проблема решается следующим образом:
Событие `onclick` происходит на кнопке
Потом оно переходит("всплывает") к `div'у`
Событие переходит на внешние элементы. Если их нет, то к `body`.
В нашем примере выше сработают оба обработчика. И мы получим сначала '`button`', а потом '`div`'

    event.target

Как отличить "оригинальное" событие от "всплывшего"? В объекте `event` есть свойство `event.target`, которое хранит ссылку на объект, в котором произошло событие изначально.

    event.stopPropagation()

Если же мы хотим приостановить всплытие события то нам необходимо вызвать метод `stopPropagation()` из объекта `event`.
#Что такое "делегирование" событий?
Обычно делегирование – это средство оптимизации интерфейса. Мы используем один обработчик для схожих действий на однотипных элементах. 

#Написать фукнцию isPolindrom , которая принимает на вход строку и возвращает результат проверки, является строка полндромом (одинакого читается с лева на право и с права на лево ) или нет

    function isPolindrom(word) {
    	return word.split('').reverse().join('') === word;
    };
    console.log(isPolindrom("asddsa")); // true
    console.log(isPolindrom("asbdsa")); // false
#Написать функцию isDeepEqual которая принимает на вход два объекта и проверяет идентичны ли они по содержимому. 

    function isDeepEqual(a, b) {
      if (a === b) return true;
      
      var propsInA = 0, propsInB = 0;
    
      for (var prop in a)
        propsInA += 1;
    
      for (prop in b) {
        propsInB += 1;
        if (!(prop in a) || !isDeepEqual(a[prop], b[prop]))
          return false;
      }
    
      return propsInA == propsInB;
    }
    var a = { prop1: 1, list: [1,2,3], o: { x: 2 } };
    var b = { list: [1,2,3], o: { x: 2 } };
    console.log(isDeepEqual(a, b)); // false
    
    b.prop1 = 1;
    console.log(isDeepEqual(a, b)); // true
#Создать конструктор с методами, так, чтобы следующий код работал и делал соответствующие вещи

    var u = new User();
    u.askName().askAge().showAgeInConsole().showNameInAlert();

    function User() {
     
       this.askName = function() {
         this.name = prompt("What is your name", "Name");
         return this;
       };
     
       this.askAge = function() {
         this.age = prompt("How old are your?", "Age");
         return this;
       };
     
       this.showAgeInConsole = function() {
         console.log("Your age: " + this.age);
         return this;
       };
     
       this.showNameInAlert = function() {
         alert("Your name: " + this.name);
         return this;
       };
     };
    
    var u = new User();
     u.askName().askAge().showAgeInConsole().showNameInAlert();
#Написать код, который для объекта созданного с помощью конструктора будет показывать, что объект является экземпляром двух классов

    function PreUser() {};
    PreUser.prototype = [1,2,3];
    
    var preUser = new PreUser();
    
    function User(){};
    User.prototype = preUser;
    
    var user = new User();
    
    
    console.log(User === PreUser); // false
    console.log(user instanceof Array); // true
    console.log(user instanceof User);// true
    console.log(user instanceof PreUser); // true

  	
ВОПРОСЫ
______________________________________________________________________________________

SOLID

Это сокращение, которое обозначает пять основных принципов объектно-ориентированного программирования.
S - Принцип единственной ответственности (The Single Responsibility Principle) Существует лишь одна причина, приводящая к изменению класса.
O - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
L - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»
I - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
D - Принцип инверсии зависимостей (The Dependency Inversion Principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
______________________________________________________________________________________

KISS 

Принцип проектирования. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.
______________________________________________________________________________________

DRY

Don’t repeat yourself

Когда вы разрабатываете крупный проект, часто приходится сталкиваться с избыточной общей сложностью реализации. Люди плохо справляются с управлением сложных систем, им лучше удается находить необычные решения определенных задач. Самое простое решение по уменьшению сложности – разделить систему на мелкие, независимые модули, которыми проще управлять.

Самый простой подход по уменьшению сложности — разделить систему на управляемые части.К примеру, частью любой CMS, является компонент, отвечающий за управление пользователями. Этот компонент может быть разделен на другие компоненты, допустим, управление уровнями доступа, который сможет работать с другими компонентами системы безопасности.

Разделяя таким образом систему на компоненты глубже и глубже, вы достигнете момента, когда каждая часть системы будет отвечать за четко определенные действия. Такие действия можно организовать в классы. Классы будут содержать методы и свойства. Методы представляют алгоритмы, которые строят бизнес логику вашей системы.

Принцип DRY требует, чтобы такие части информации встречались в вашем коде один, и только один раз. Эти части должны иметь одно представление.
______________________________________________________________________________________

YAGNI

«You ain't gonna need it» — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.

______________________________________________________________________________________

MVC

Model-View-Controller — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.
- Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.
- Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели.
- Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.
______________________________________________________________________________________

Паттерны проектирования ( Какие есть группы? )

Шаблоны проектирования — это проверенные и готовые к использованию решения часто возникающих в повседневном программировании задач. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее. Шаблон проектирования, подходящий под задачу, реализуется в каждом конкретном случае. Кроме того, он не зависит от языка программирования. Хороший шаблон легко реализуется в большинстве, если не во всех языках, в зависимости от выразительных средств языка. Следует, однако, помнить, что такой шаблон, будучи примененным неправильно или к неподходящей задаче, может принести немало проблем. Тем не менее, правильно примененный шаблон поможет решить задачу легко и просто.

Существует три типа шаблонов:

- Структурные шаблоны определяют отношения между классами и объектами, позволяя им работать совместно.

- Порождающие шаблоны предоставляют механизмы инициализации, позволяя создавать объекты удобным способом.

- Поведенческие шаблоны используются для того, чтобы упростить взаимодействие между сущностями.

______________________________________________________________________________________

Антипаттерны проектирования

Анти-паттерны — полная противоположность паттернам. Если паттерны проектирования — это примеры практик хорошего программирования, то есть шаблоны решения определённых задач. То анти-паттерны — их полная противоположность, это — шаблоны ошибок, которые совершаются при решении различных задач. Частью практик хорошего программирования является именно избежание анти-паттернов. Не надо думать, что это такая непонятная теоретическая фигня — это конкретные проблемы, с которыми сталкивался практически каждый разработчик.

Некоторые из них:

- Программирование копи-пастом (Copy and Paste Programming) Когда от программиста требуется написание двух схожих функций, самым «простым» решением является написание одной функции, её копирование и внесение некоторых изменений в копию. Какие проблемы это сулит? Во-первых, ухудшается переносимость кода — если потребуется подобный функционал в другом проекте, то надо будет искать все места, где программист накопипастил и переносить их по отдельности. Во-вторых, понижается качество кода — часто программист забывает вносить требуемые изменения в скопированный код. В-третьих, усложняется поддержка кода — так, как если в изначальном варианте был баг, который в будущем надо будет исправить, то этот баг попал во все то, что, опять-таки, накопипастил программист.

- Спагетти-код (Spaghetti code) — слабо структурированная и плохо спроектированная система, запутанная и очень сложная для понимания. Такой код так же очень часто содержит в себе множество примеров анти-паттерна программирования копи-пастом. Подобный код в будущем не сможет разобрать даже его автор. В ООП спагетти-код может быть представлен в виде небольшого количества объектов с огромными, по размеру кода, методами.

- Золотой молоток (Golden hammer) — уверенность в полной универсальности любого решения. На практике, это — применение одного решения (чаще всего какого-либо одного паттерна проектирования) для всех возможных и невозможных задач. С этим надо бороться — для каждой задачи имеется не одно, а несколько, красивых и оптимальных решений — именно к поиску таких решений и сводится эффективная разработка. И только такая разработка позволит создать эффективную систему.

- «Что за 42?» или Магические числа (Magic numbers) — константа, использованная в коде для чего либо (чаще всего — идентификации данных), само число не несёт никакого смысла без соответствующего комментария. Числа не несут абсолютно никакой семантики. Когда в коде вашего проекта начинаются появлятся числа, значение которых не является очевидным — это очень плохо. Программист, который не является автором такого кода, с трудностями сможет объяснить как это работает. Со временем и автор кода, с присутствием магических чисел, не сможет объяснить что-либо. Числа затрудняют понимание кода и его рефакторинг. Главными причинами этой ошибки — спешка при разработке, отсутствие практики программирования. Данный анти-паттерн надо пресекать на корню, оговаривая использование числовых констант перед началом разработки.

- Жёсткое кодирование (Hard code) — внедрение различных данных об окружении в реализацию. Например — различные пути к файлам, имена процессов, устройств и так далее. Этот анти-паттерн тесно связан с магическими числами, частенько они переплетаются. Захардкодить — жёстко прописать значение каких-либо данных в коде. Главная опасность, исходящая от этого анти-паттерна — непереносимость. В системе разработчика код будет исправно работать до перемещения или переименования файлов, изменения конфигурации устройств. На любой другой системе код может вовсе не заработать сразу же. Как правило, программист практически сразу забывает где и что он захардкодил, даже если делает это в целях отладки кода. Это делает выявление и локализацию данного анти-паттерна очень сложной. С этим надо бороться — оговорив запрет на жёсткое кодирование перед началом разработки и проводя тщательные code review.

- Мягкое кодирование (Soft code) Мягкое кодирование — параноидальная боязнь жёсткого кодирования. Это приводит к тому, что незахардкожено и настраивается абсолютно всё, что делает конфигурацию невероятно сложной и непрозрачной. Этот анти-паттерн является вторым концом палки о жёстком кодировании и поэтому тоже является опасным. Во-первых, при разработке много ресурсов уходит на реализацию возможности настроек абсолютно всего. Во-вторых, развёртывание такой системы повлечет так же дополнительные затраты. Перед началом решения определённой задачи следует определить, что должно быть настариваемым, а что является постоянным для различных систем или может быть настроено автоматически.

- Ненужная сложность (Accidental complexity) Простыми словами — это заумность решения. Ненужная сложность может быть внесена в решение любой задачи. Это могут быть как и ненужные проверки, части кода, продуцированные мягким кодированием, отсутствие какой-либо оптимизации. Это приводит к усложнению понимания кода, понижению скорости работы. Причинами являются — отсутствие или некачественность рефакторинга, некомпетентность программиста. Бороться довольно просто — следует проводить тщательные code review, эффективный рефакторинг.

- Лодочный якорь (Boat anchor) Этот анти-паттерн означает сохранение неиспользуемых частей системы, которые остались после оптимизации или рефакторинга. Часто, после рефакторинга когда, который является результатом анти-паттерна, некоторые части кода остаются в системе, хотя они уже больше не используются. Так же некоторые части кода могут быть оставлены «на будущее», авось придётся ещё их использовать. Такой код только усложняет системы, не неся абсолютно никакой практической ценности. Эффективным методом борьбы с лодочными якорями является рефакторинг кода для их устранения, а так же процесс планирования разработки, с целью предотвращения возникновения якорей.

- Изобретение велосипеда (Reinventing the wheel) Смысл этого анти-паттерна в том, что программист разрабатывает собственное решение для задачи, для которой уже существуют решения, очень часто лучшие чем придуманное программистом. Разработчик считает себя наилучшим, поэтому для каждой задачи пытается придумать собственное решение, не смотря на опыт его предшественников. Чаще всего это приводит лишь к потере времени и понижению эффективности работы программиста — так как решение может быть найдено далеко неоптимальное или вообще ненайденное. Полностью же отбрасывать возможность самостоятельного решения нельзя, так как это прямой дорогой к приведет к программированию копипастом. Разработчик должен ориентироваться в задачах, которые могут предстать перед ним, чтобы грамотно их решить — используя готовые решение или изобретая собственные. Очень часто причиной этого анти-паттерна является банальная нехватка времени. А время — это деньги.

- Изобретение одноколёсного велосипеда (Reinventing the square wheel) Этот анти-паттерн очень тесно связан с простым изобретением велосипеда — это создание своего плохого решения, при существовании лучшего. Этот анти-паттерн вдвойне забирает время — так как, во-первых, время тратится на изобретение и реализацию собственного решения, во-вторых, время тратится при рефакторинге таких решений и замене их оптимальными. Программист должен быть осведомлен о существовании различных решений для определённых кругов задач, ориентироваться в их преимуществах и недостатках.

- «От твоего кода дурно пахнет» или Поток лавы (Lava flow) На каком либо этапе разработки вы можете осознать, что некоторая часть кода очень давно не менялась и вообще недокументирована, или такому коду сопутствует комментарий вида "// Не знаю, как оно работает, но оно работает. Не удалять и не менять!". Если ничего не предпринимать, то такой код и останется в проекте. Но и рефакторить, разбирать его довольно сложно, особенно ели его автор уже не работает над проектом. Проще предусмотреть возникновение такого мёртвого кода, при разработке надо руководствоваться тем, что код в будущем возможно будет немного оптимизирован или дописан, но никак не переписан полностью. Главными причинами возникновения потоков лавы являются — написание больших частей проекта одним программистом, отсутствие code review, ошибки в проектировании архитектуры. 

- «А если i+1?» или Программирование перебором (Programming by permutation) Многие начинающие программисты пытаются решать некоторые задачи методом перебора — не брутфорсом решения, а именно подбором параметров, порядка вызова функций и так далее. Все эти игры с +1, -1 к параметрам и подобные штучки устраняют только симптомы, и не дают понимания сути происходящего. А если программист не понимает происходящего, то он не сможет предусмотреть все варианты развития событий и обязательно о чём-то забудет. Он потратит время на подбор работающего для него решения и позднее потратит время для переделки этого решения. Все подобные подобранные решения вылазят боком и хорошо ещё — если в процессе разработки или отладки. К подобному ни в коем случае нельзя привыкать, достигая успеха на небольших задачках. Если программист не может решать задачи другим путём — он некомпетентен и ему не следует доверять разработку — вам же будет хуже.

- «Как это вы передали строку вместо числа?!» или Слепая вера (Blind faith) Этот анти-паттерн — недостаточная проверка корректности входных данных, исправления ошибки или результатов работы кода. Очень часто программист думает, что его код всегда будет в идеальных условиях, никогда не выдаст ошибки и не получит неверных входных данных или, ещё чего, данных неверного типа. Но все лгут ©, поэтому нельзя доверять никакому коду, даже собственному. Но и не следует доводить это недоверие до паранойи, то есть приходить к анти-паттерну ненужной сложности. Просто следует помнить про проверку входных данных и возможные проблемы у чужого кода, который используете вы.

- Бездумное комментирование - Результат «работы» данного анти-паттерна — большое количество лишних и неинформативных комментариев. Код не следует комментировать ради комментирования! Ведь комментарии — очень полезный инструмент, который должен помочь задокументировать нужную информацию для облегчения понимания кода, как автору в будущем, так и другим разработчикам. Ни в коем случае нельзя допускать диалога разработчиков в комментариях — лучше перенести данную функцию с комментариев на специализированные инструменты для code review, или на личное обсуждение.

- Божественный объект (God Object) «Мне нужен такой-то функционал. — Используй MegaCoreObject! — И ещё, мне нужен и… — Я же сказал, используй MegaCoreObject!» Божественный объект — анти-паттерн, который довольно часто встречается у ООП разработчиков. Такой объект берет на себя слишком много функций и/или хранит в себе практически все данные. В итоге мы имеем непереносимый код, в котором, к тому же, сложно разобраться. Так же, подобный код довольно сложно поддерживать, учитывая, что вся система зависит практически только от него. Причинами являются — некомпетентность разработчика, взятие одним разработчиком большой части работы (особенно, когда размер работы «превышает» уровень опыта этого разработчика). Бороться с таким подходом надо — разбивать задачи на подзадачи, с возможностью решения этих подзадач различными разработчиками.
______________________________________________________________________________________

Модульные системы (CommonJS/ ES6 modules/ AMD)

Модуль — это переиспользуемая часть кода, содержащая в себе детали реализации и предоставляющая открытое API, что позволяет легко загрузить её и использовать в другом коде.

В идеале, модули JavaScript позволяют нам:
- абстрагировать код, передавая функциональные возможности сторонним библиотекам, так что нам не придётся разбираться во всех сложностях их реализации;
- инкапсулировать код, скрывая его внутри модуля, если не хотим, чтобы его изменяли;
- переиспользовать код, избавляясь от необходимости писать одно и то же снова и снова;
- управлять зависмостями, легко изменяя зависимости без необходимости переписывать наш код.

Формат модуля — это синтаксис, который используется для его определения.

До создания ECMAScript 6, или ES2015, в JavaScript не было официального синтаксиса для определения модулей. А значит, опытные разработчики предлагали разные форматы определения.

Вот несколько наиболее известных и широко используемых:
- асинхронное определение модуля (Asynchronous Module Definition или AMD);
- CommonJS;
- универсальное определение модуля (Universal Module Definition или UMD);
- System.register;
- формат модуля ES6.

Асинхронное определение модуля (AMD)

Формат AMD используется в браузерах и применяет для определения модулей функцию define:
```
//Вызов функции define с массивом зависимостей и фабричной функцией
define(['dep1', 'dep2'], function (dep1, dep2) {
	//Определение модуля с помощью возвращаемого значения
	return function () {};
});
```
Формат CommonJS

Формат CommonJS применяется в Node.js и использует для определения зависимостей и модулей require и module.exports:
```
var dep1 = require('./dep1');  
var dep2 = require('./dep2');
 
module.exports = function(){  
 // ...
}
```
Универсальное определение модуля (UMD)

Формат UMD может быть использован как в браузере, так и в Node.js.
```
(function (root, factory) {
 if (typeof define === 'function' && define.amd) {
   // AMD. Подключение анонимного модуля
     define(['b'], factory);
 } else if (typeof module === 'object' && module.exports) {
   // Node. Не работает с CommonJS напрямую, 
   // только CommonJS-образными средами, которые поддерживают      
 
   // module.exports, как Node.
   module.exports = factory(require('b'));
 } else {
   // Глобальные переменные браузера (root это window)
   root.returnExports = factory(root.b);
 }
}(this, function (b) {
 //как-нибудь использовать b.
 
 // Просто возвращаем значение для определения модуля.
 // Этот пример возвращает объект, но модуль 
 // может вернуть и функцию как экспортируемое значение.
 return {};
}));
```
System.registerА

Формат System.register был разработан для поддержки синтаксиса модулей ES6 в ES5:
```
import { p as q } from './dep';
 
var s = 'local';
 
export function func() {  
 return q;
}
 
export class C {  
}
```
Формат модулей ES6

В ES6 JavaScript уже поддерживает нативный формат модулей.

Он использует токен export для экспорта публичного API модуля:
```
// lib.js
 
// Экспорт функции
export function sayHello(){  
 console.log('Hello');
}
 
// Не экспоруемая функция
function somePrivateFunction(){  
 // ...
}
```
и токен import для импорта частей, которые модуль экспортирует:
```
import { sayHello } from './lib';
 
sayHello();  
// Hello
```
Мы можем даже присваивать импорту алиас, используя as:
```
import { sayHello as say } from './lib';
 
say();  
// Hello
```
или загружать сразу весь модуль:
```
import * as lib from './lib';
 
lib.sayHello();  
// Hello
```
Формат также поддерживает экспорт по умолчанию:
```
// lib.js
 
// Экспорт дефолтной функции
export default function sayHello(){  
 console.log('Hello');
}

// Экспорт недефолтной функции
export function sayGoodbye(){  
 console.log('Goodbye');
}
```
который можно импортировать, например, так:
```
import sayHello, { sayGoodbye } from './lib';
 
sayHello();  
// Hello
 
sayGoodbye();  
// Goodbye
```
Вы можете экспортировать не только функции, но и всё, что пожелаете:
```
// lib.js
 
// Экспорт дефолтной функции
export default function sayHello(){  
 console.log('Hello');
}
 
// Экспорт недефолтной функции
export function sayGoodbye(){  
 console.log('Goodbye');
}
 
//  Экспорт простого значения
export const apiUrl = '...';
 
// Экспорт объекта
export const settings = {  
 debug: true
}
```
К сожалению, нативный формат модулей пока поддерживают не все браузеры.

Мы можем использовать формат модулей ES6 уже сегодня, но для этого потребуется компилятор наподобие Babel, который будет переводить наш код в формат ES5, такой, как AMD или CommonJS, перед тем, как код будет запущен в браузере.
______________________________________________________________________________________

RequireJS

Всем известен классический способ подгрузки JS файлов с использование <script> тегов. Этим способом мы пользуемся уже очень давно и скорее всего будем продолжать. Однако, при этом есть ряд минусов:

- список загружаемых скриптов определяется в html файле, тогда как основной код пишется в файлах JS – такое разделение приоритетов не всегда удобно
- подгружаемые библиотеки “засоряют” глобальное пространство имен, что тоже не очень желательно
- зачастую при подключении библиотек важно соблюдать определенный порядок загрузки, иначе ваш код может перестать работать

Таким образом для эффективной работы явно нужен другой подход – более динамичный, подходящий для сложных, разветвленных проектов с большим числом зависимостей. Такое решение как раз и предоставляет библиотека RequireJS. RequireJS использует асинхронную модель подгрузки зависимостей – AMD.

MD вкратце можно описать следующей формулой, которая объявляет ваш модуль:
```
/**
 * id (optional) - unique id of the module (which is really just a path to the module)
 * dependencies (optional) - array of dependencies
 * factory (required) - return exported value of the module
 */
define(id, dependencies, factory);
```
Что же происходит, когда мы объявляем свой модуль, который зависит от сторонних библиотек:
```
// app.js
define(['jquery', 'd3'], function($, d3){
 
  // some awesome code
 
});
```
Код выше дает команду RequireJS подгрузить две дополнительные библиотеки (если они еще не были до этого загружены). Никакой магии подгрузка осуществляется стандартными технологиями браузера:
```
<head>
  <!-- ...some tags... -->
  <script src="./js/app.js"></script>
  <script src="./js/jquery.js"></script>
  <script src="./js/d3.js"></script>
</head>
```
Использование модулей зависит во многом от того, что возвращает функция factory, которая и определяет работу модуля. Это может быть объект:
```
// person.js
define(function(){
  return {
    name: 'David',
    sayHello: function() {
      console.log( 'Hi there, ' + this.name );
    }
  }
});
 
// app.js
define(['person'], function(person){
  person.sayHello(); // Hi there, David
});
```
Или функция:
```
// sum.js
define(function(){
  return function(a, b) {
    console.log(a + b);
  }
})
 
// app.js
define(['sum'], function(sum){
  sum(10, 4) // 14
});
```
Можно также использовать модуль для хранения и передачи набора констант. В этом случае можно не объявлять функцию, а просто передать объект с данными:
```
// contsants.js
define({
  pi: 3.14142,
  e: 2.7182818
});
 
// app.js
define(['constants'], function(constants){
  console.log(constants.pi); // 3.14142
});
```
Впрочем модуль может вообще ничего не возвращать, это не является обязательным условием.

define vs require

Используйте define(), если вы хотите объявить модуль, от которого будут зависеть другие части вашего приложения.
Используйте require(), когда хотите запустить функцию, которая зависит от модулей, объявленных отдельно. В require() вы не объявляете новые модули.
